# Problem: Remove Duplicates In-Place from Sorted Array

**GFG Link**: https://www.geeksforgeeks.org/problems/remove-duplicate-elements-from-sorted-array/1  
**LeetCode Link**: https://leetcode.com/problems/remove-duplicates-from-sorted-array/

---

## 1. Problem Statement

**English**:  
Given a **sorted array in non-decreasing order**, remove duplicates **in-place** so that each unique element appears **only once**.  
Return the **number of unique elements** (`k`).  
The **first `k` elements** should hold the final result.  
**Order must be preserved**. Values beyond `k` don’t matter.

**Hinglish**:  
Sorted array se duplicates hatao **bina extra space ke**.  
Sirf unique elements rehne chahiye — pehle `k` jagah pe.  
Return karo `k`.

---

## 2. Input / Output / Constraints

**Input Example**:  
`arr = [1, 1, 2, 2, 2, 3, 3]`  
**Output Expected**:  
`k = 3`, `arr = [1, 2, 3, _, _, _, _]`

**Constraints**:  
- `0 ≤ arr.length ≤ 3 * 10⁴`  
- `-100 ≤ arr[i] ≤ 100`  
- Array is **sorted in non-decreasing order**

---

## 3. Examples (All Cases Covered)

| Example | Input | Output (`k`) | Final Array (first k) | Why |
|-------|-------|--------------|------------------------|-----|
| 1 | `[1,1,2,2,2,3,3]` | `3` | `[1,2,3]` | Normal case |
| 2 | `[1,1,1,2,2,3,3,3,4,4]` | `4` | `[1,2,3,4]` | Long duplicates |
| 3 | `[]` | `0` | `[]` | Empty |
| 4 | `[5]` | `1` | `[5]` | Single element |
| 5 | `[1,2,3,4]` | `4` | `[1,2,3,4]` | No duplicates |
| 6 | `[2,2,2,2]` | `1` | `[2]` | All same |

---

## 4. Intuition & Core Thinking

> **Since array is sorted → duplicates are adjacent!**

Think of it like:  
> "I’m walking through a line of people. If the next person is the **same** as the last one I kept, I skip. If **different**, I keep them."

Key Insight:  
- Use **two pointers**:  
  - `i` → position to place **next unique** element  
  - `j` → current element we’re checking  
- Start with `i = 0` (first element is always kept)  
- When `arr[j] != arr[i]` → place it at `i+1`

---

# APPROACHES (Brute → Optimal)

---

## Approach 1: Brute Force – Using Set

### Intuition  
Insert all elements into a `set` → copy unique elements back to front.

### Why This Approach?  
- Easy to code  
- Handles duplicates automatically  
- Teaches set usage

### Why Move to Next?  
- **O(n) extra space** → violates **in-place**  
- **Not allowed in interviews**  
- Slower due to hashing

---

### Algorithm  
1. Insert all elements into `unordered_set`  
2. Copy set elements back to `arr[0..k-1]`  
3. Return `k = set.size()`

---

### Pseudocode  
``` 
function removeWithSet(arr):  
    set = empty  
    for x in arr:  
        set.insert(x)  
    for i from 0 to set.size()-1:  
        arr[i] = set[i]  
    return set.size()
```

---

### Code

#### C++
```cpp
int removeWithSet(vector<int>& arr) {
    unordered_set<int> s(arr.begin(), arr.end());
    int k = 0;
    for (int x : s) {
        arr[k++] = x;
    }
    return k;
}
```

#### JavaScript
```js
function removeWithSet(arr) {
    let set = new Set(arr);
    let k = 0;
    for (let x of set) {
        arr[k++] = x;
    }
    return k;
}
```

* Time Complexity: **O(n)**  
* Space Complexity: **O(n)** → **Not in-place**

---

## Approach 2: Two Pointers (Optimal & In-Place)

### Intuition  
> **Exploit sorted property → duplicates are together**

Use:
- `i` → index of **last unique element**  
- `j` → current element

**Only move `i` when we find a new value**

### Why This Approach?  
- **O(1) space**  
- **O(n) time**  
- **In-place**  
- **Interview favorite**

### Why This is Final?  
- **Optimal**  
- Clean, fast, production-ready  
- No better in-place method

---

### Algorithm  
1. If `n == 0` → return `0`  
2. `i = 0`  
3. For `j = 1` to `n-1`:  
  If `arr[j] != arr[i]`:  
   `i++`  
   `arr[i] = arr[j]`  
4. Return `i + 1`

---

### Pseudocode  
``` 
function removeDuplicates(arr):  
    if arr.empty: return 0  
    i = 0  
    for j from 1 to n-1:  
        if arr[j] != arr[i]:  
            i += 1  
            arr[i] = arr[j]  
    return i + 1
```

---

### Dry Run: [1,1,2,2,2,3,3]

| j | arr[j] | arr[i] | arr[j] != arr[i]? | Action | i | arr |
|---|--------|--------|-------------------|-------|---|-----|
| 1 | 1      | 1      | No                | skip  | 0 | [1,1,2,2,2,3,3] |
| 2 | 2      | 1      | Yes               | i=1, arr[1]=2 | 1 | [1,2,2,2,2,3,3] |
| 3 | 2      | 2      | No                | skip  | 1 | — |
| 4 | 2      | 2      | No                | skip  | 1 | — |
| 5 | 3      | 2      | Yes               | i=2, arr[2]=3 | 2 | [1,2,3,2,2,3,3] |
| 6 | 3      | 3      | No                | skip  | 2 | — |

**Final**: `k = 3`, `arr = [1,2,3,_,_,_,_]`

---

### Code

#### C++
```cpp
int removeDuplicates(vector<int>& arr) {
    int n = arr.size();
    if (n == 0) return 0;
    int i = 0;
    for (int j = 1; j < n; j++) {
        if (arr[j] != arr[i]) {
            arr[++i] = arr[j];
        }
    }
    return i + 1;
}
```

#### JavaScript
```js
function removeDuplicates(arr) {
    let n = arr.length;
    if (n === 0) return 0;
    let i = 0;
    for (let j = 1; j < n; j++) {
        if (arr[j] !== arr[i]) {
            arr[++i] = arr[j];
        }
    }
    return i + 1;
}
```

* Time Complexity: **O(n)**  
* Space Complexity: **O(1)**

---

## Approach 3: STL `unique` (Production)

### Intuition  
Use built-in `std::unique` → returns iterator to new end.

### Why This?  
- **One-liner**  
- **Highly optimized**  
- **Real-world code**

### Why Not Always?  
- Interviewers want **manual logic**

---

### Code

#### C++
```cpp
#include <algorithm>
int stlApproach(vector<int>& arr) {
    auto it = unique(arr.begin(), arr.end());
    return it - arr.begin();
}
```

#### JavaScript (No built-in → use filter)
```js
function filterApproach(arr) {
    let k = 0;
    for (let i = 0; i < arr.length; i++) {
        if (i === 0 || arr[i] !== arr[i-1]) {
            arr[k++] = arr[i];
        }
    }
    return k;
}
```

---

## 5. Edge Case List (Line-wise)

| Edge Case | Input | Expected `k` | Final Array | Handled? |
|---------|-------|--------------|-------------|---------|
| Empty | `[]` | `0` | `[]` | Yes |
| Single | `[5]` | `1` | `[5]` | Yes |
| All same | `[2,2,2]` | `1` | `[2]` | Yes |
| No duplicates | `[1,2,3]` | `3` | `[1,2,3]` | Yes |
| All unique | `[1,3,5,7]` | `4` | `[1,3,5,7]` | Yes |
| Two groups | `[1,1,3,3]` | `2` | `[1,3]` | Yes |

---

## 6. Complexity Summary

| Approach | Time | Space | Best For |
|--------|------|-------|----------|
| Set | O(n) | O(n) | Learning |
| **Two Pointers** | **O(n)** | **O(1)** | **Interviews (Optimal)** |
| STL `unique` | O(n) | O(1) | Production |

---

## 7. Final Consolidated Code

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Brute: Set
    int removeWithSet(vector<int>& arr) {
        unordered_set<int> s(arr.begin(), arr.end());
        int k = 0;
        for (int x : s) arr[k++] = x;
        return k;
    }

    // Optimal: Two Pointers
    int removeDuplicates(vector<int>& arr) {
        int n = arr.size();
        if (n == 0) return 0;
        int i = 0;
        for (int j = 1; j < n; j++) {
            if (arr[j] != arr[i]) {
                arr[++i] = arr[j];
            }
        }
        return i + 1;
    }

    // STL
    int stlApproach(vector<int>& arr) {
        auto it = unique(arr.begin(), arr.end());
        return it - arr.begin();
    }
};
```

### JavaScript
```javascript
class Solution {
    // Brute: Set
    removeWithSet(arr) {
        let set = new Set(arr);
        let k = 0;
        for (let x of set) {
            arr[k++] = x;
        }
        return k;
    }

    // Optimal: Two Pointers
    removeDuplicates(arr) {
        let n = arr.length;
        if (n === 0) return 0;
        let i = 0;
        for (let j = 1; j < n; j++) {
            if (arr[j] !== arr[i]) {
                arr[++i] = arr[j];
            }
        }
        return i + 1;
    }

    // Filter style
    filterApproach(arr) {
        let k = 0;
        for (let i = 0; i < arr.length; i++) {
            if (i === 0 || arr[i] !== arr[i-1]) {
                arr[k++] = arr[i];
            }
        }
        return k;
    }
}
```

---

## 8. Interview Strategy

1. **Start**: "Since array is **sorted**, duplicates are **adjacent** → I’ll use **two pointers** in **O(1) space**."  
2. "Keep `i` at last unique position. For each `j`, if `arr[j] != arr[i]` → place at `i+1`."  
3. "Return `i+1` as count of unique elements."  
4. "Edge cases: empty → 0, all same → 1, no duplicates → n."  
5. **Bonus**: "Set uses O(n) space — not allowed. This is **optimal**."
