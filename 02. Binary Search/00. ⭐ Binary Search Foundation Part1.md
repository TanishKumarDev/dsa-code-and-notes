# Binary Search
**(Just like your Arrays & Inversion notes – full depth, Hinglish, dry-runs, codes, everything!)**

---

### 1. Problem Statement (Classic)

**English**:  
Given a **sorted array** (non-decreasing order) of `n` integers and a `target`,  
find the **index** of the target. If not present → return `-1`.

**Hinglish**:  
Sorted array hai → target dhundho, index return karo, nahi mila to -1.

**LeetCode**: [704. Binary Search](https://leetcode.com/problems/binary-search/)  
**GFG**: Search in a sorted array

---

### 2. Input / Output / Constraints

| Example | Input Array             | Target | Output | Why |
|-------|--------------------------|--------|--------|-----|
| 1     | `[1,2,3,4,5,6,7]`       | 4      | 3      | Present |
| 2     | `[1,3,5,7,9]`           | 6      | -1     | Not present |
| 3     | `[10]`                  | 10     | 0      | Single element |
| 4     | `[]` (empty)            | 5      | -1     | Empty array |
| 5     | `[2,2,2,2,2]`           | 2      | Any valid index (0-4) | Duplicates |

**Constraints**  
- `1 ≤ n ≤ 10⁵`  
- `-10⁹ ≤ arr[i], target ≤ 10⁹`  
- Array is **sorted in non-decreasing order**

---

### 3. Real-Life Intuition (Dictionary Wala Example)

> Imagine a thick dictionary (sorted alphabetically)

**Linear Search** → page 1 se last tak dekho → O(n)  
**Binary Search** →  
1. Book ko beech mein kholo  
2. Dekho left page pe “S” se shuru hai → “raj” isse pehle hoga → right half hatao  
3. Ab left half ko beech mein kholo → repeat  
→ Har baar aadha part fek dete ho → **log n steps** mein mil jata hai!

**Golden Rule**: Binary Search tabhi kaam karega jab data **sorted** ho!

---

### 4. Core Concept – Search Space

```
low = 0                high = n-1
    ↓-----------------------↓
    |   Search Space (sorted)   |
```

- **Search Space** = all elements between `low` and `high` (including them)
- Har step mein hum search space ko **exactly half** karte hain
- Jab `low > high` → search space khatam → target nahi mila

---

### 5. The Famous Mid Calculation Bug (MUST KNOW)

```cpp
int mid = (low + high) / 2;        // WRONG for big arrays → Integer Overflow!
```

**Correct Ways** (choose any one):

```cpp
int mid = low + (high - low) / 2;           // Best & Safe
int mid = (low + high) >> 1;                // Bitwise (fast)
int mid = low + ((high - low) >> 1);        // Most preferred
```

---

### 6. Approaches

#### Approach 1: Iterative Binary Search (Most Used in Interviews)

```cpp
int binarySearch(vector<int>& arr, int target) {
    int n = arr.size();
    int low = 0, high = n - 1;

    while (low <= high) {                    // Important: <=
        int mid = low + (high - low) / 2;

        if (arr[mid] == target)
            return mid;

        else if (arr[mid] < target)
            low = mid + 1;                   // Right half

        else
            high = mid - 1;                  // Left half
    }
    return -1;                               // Not found
}
```

#### Approach 2: Recursive Binary Search

```cpp
int solve(vector<int>& arr, int low, int high, int target) {
    if (low > high) return -1;

    int mid = low + (high - low) / 2;

    if (arr[mid] == target) return mid;
    if (arr[mid] < target)
        return solve(arr, mid + 1, high, target);
    else
        return solve(arr, low, mid - 1, target);
}

int search(vector<int>& arr, int target) {
    return solve(arr, 0, arr.size() - 1, target);
}
```

---

### 7. Dry Run → arr = [2,3,4,6,8,10,12], target = 8

| Step | low | high | mid | arr[mid] | Action            |
|------|-----|------|-----|----------|-------------------|
| 1    | 0   | 6    | 3   | 6        | 8 > 6 → low = 4   |
| 2    | 4   | 6    | 5   | 10       | 8 < 10 → high = 4 |
| 3    | 4   | 4    | 4   | 8        | Found! → return 4 |

---

### 8. Full Working Code (C++ & JavaScript)

#### C++ (Iterative – Interview Favorite)

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        int low = 0, high = n - 1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                low = mid + 1;
            else
                high = mid - 1;
        }
        return -1;
    }
};
```

#### JavaScript

```js
function binarySearch(arr, target) {
    let low = 0, high = arr.length - 1;

    while (low <= high) {
        let mid = low + Math.floor((high - low) / 2);

        if (arr[mid] === target) return mid;
        else if (arr[mid] < target) low = mid + 1;
        else high = mid - 1;
    }
    return -1;
}

// Test
console.log(binarySearch([2,3,4,6,8,10,12], 8));  // 4
console.log(binarySearch([1,2,3,4,5], 9));       // -1
```

---

### 9. Edge Cases Covered

| Case                  | Handled? | How |
|-----------------------|----------|-----|
| Empty array           | Yes      | high = -1 → loop nahi chalega |
| Single element        | Yes      | low = high = 0 |
| Target at start       | Yes      | mid = 0 → found |
| Target at end         | Yes      | last iteration |
| Target not present    | Yes      | low > high → return -1 |
| Duplicates            | Yes      | Will return any one index |
| Integer overflow      | Yes      | `low + (high-low)/2` |

---

### 10. Complexity Analysis

| Approach      | Time          | Space    | Best For              |
|---------------|---------------|----------|-----------------------|
| Linear Search | O(n)          | O(1)     | Not acceptable        |
| **Binary Search** | **O(log n)** | **O(1)** (iterative) | **Interviews**        |
| Recursive BS  | O(log n)      | O(log n) (call stack) | Learning recursion |

**Final Verdict**: Iterative Binary Search is the **only acceptable** solution for interviews.

---

### 11. Pro Tips

1. **Hamesha `low + (high-low)/2` use karo** → overflow se bacho  
2. Loop condition → `while(low <= high)`  
3. Binary search **sirf sorted data** pe kaam karta hai  
4. Search space shrink karte raho → ya to left half ya right half  
5. Jab `low > high` → target nahi hai

---