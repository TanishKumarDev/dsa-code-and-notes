### Why does **Minimum always lie in the unsorted segment** of a rotated sorted array?

---

### Base Logic

Consider a **sorted** array:

```
[0, 1, 2, 4, 5, 6, 7]
```

If we rotate it (cut at pivot & append):

```
[4, 5, 6, 7, 0, 1, 2]
         ^
       pivot
```

The array now has **two parts**:

| Left part (sorted) | Right part (sorted) |
| ------------------ | ------------------- |
| [4, 5, 6, 7]       | [0, 1, 2]           |

Both parts are individually sorted, but **not globally sorted**.

Now where is the minimum?

```
[4, 5, 6, 7] [0, 1, 2]
              ^
            minimum
```

The **minimum is exactly where the sorted order breaks**.

In other words:

### The **minimum** is the **first element of the second sorted segment**,

and that segment is the **unsorted portion relative to the full array**.

---

### Visualizing Sorted vs Unsroted Segments

Sorted means `arr[i] <= arr[i+1]` for all valid `i`.

Check segments:

Left half:

```
4 <= 5 <= 6 <= 7   (sorted ✓)
```

Right half:

```
0 <= 1 <= 2        (sorted ✓)
```

But across the boundary:

```
7 <= 0   (FALSE)  ❌
```

That failure point is where rotation happened → contains the minimum.

---

### Another Example

Before rotation:

```
[1, 2, 3, 4, 5, 6]
```

After rotation:

```
[4, 5, 6, 1, 2, 3]
           ^
         minimum
```

Break in sorted order:

```
6 <= 1 (FALSE) → pivot/minimum is here
```

---

### Key Reasoning

In a rotated sorted array (without duplicates):

✔ One half is always strictly sorted
✔ The **minimum cannot** lie in that sorted half, unless the whole array is sorted (no rotation)

Because if the minimum were inside the sorted half, the other half would also need to be sorted for the array to be globally sorted, meaning **no rotation** occurred.

So the minimum must lie in the **other half**, the **unsorted segment**.

---

### Binary Search Decision

We check:

```
if arr[mid] > arr[high]:
    minimum is in right (unsorted) segment
else:
    minimum is in left (possibly including mid)
```

Why compare with `arr[high]`?

Because the right segment always contains the **smallest** values after rotation.

---

### Mini Proof (simple reasoning)

For distinct elements:

If `arr[mid] > arr[high]` then:

Right side is smaller and must contain the pivot/minimum:

```
[mid .... high]
  >        smallest
```

If `arr[mid] < arr[high]` then mid lies in sorted section and minimum is to the left:

```
[low .... mid ... high]
   smallest is here ^
```

---

### Final short explanation (memory version)

Memorize this:

```
A rotated sorted array is two sorted parts.
The pivot/minimum is where sorting breaks.
Sorted half cannot contain the minimum (unless no rotation).
Therefore minimum lies in the unsorted half.
```

---