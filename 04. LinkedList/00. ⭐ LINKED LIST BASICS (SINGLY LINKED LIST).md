# LINKED LIST BASICS (SINGLY LINKED LIST)


### 1. What is a Linked List?

A **Linked List** is a linear data structure where elements are stored in **separate memory locations** called **nodes**.

Each node contains:

1. **Data** (value)
2. **Pointer/Reference** to the next node

Structure:

```
[Data | Next] → [Data | Next] → [Data | Next] → NULL
```

### 2. Why Linked List exists?

Arrays have limitations:

| Feature         | Array                | Linked List         |
| --------------- | -------------------- | ------------------- |
| Size            | Fixed                | Dynamic             |
| Memory          | Continuous           | Scattered           |
| Insert/Delete   | Slow, shift elements | Fast pointer update |
| Access by index | O(1) fast            | O(n) slow           |

Linked List is used when:

* You need dynamic size (grow/shrink anytime)
* Frequent insertion/deletion at beginning or middle
* Memory is fragmented (not continuous)

### 3. Key Components

| Term | Explanation                            |
| ---- | -------------------------------------- |
| Node | Basic unit storing data + next address |
| Head | Pointer to the first node              |
| Tail | Last node (points to NULL)             |
| NULL | Marks end of list                      |

Example memory view:

```
head
 ↓
[10 | *] → [20 | *] → [30 | NULL]
```

### 4. Types of Linked Lists

| Type                 | Description                                 |
| -------------------- | ------------------------------------------- |
| Singly Linked List   | Only next pointer (one direction traversal) |
| Doubly Linked List   | next + prev pointer (two-way traversal)     |
| Circular Linked List | Last node points back to head, forms a loop |

Our focus: **Singly Linked List**

### 5. Basic Operations (Concept only)

| Operation          | Idea Summary                               |
| ------------------ | ------------------------------------------ |
| Traversal          | Visit nodes from head→NULL                 |
| Search             | Check each node’s data                     |
| Insert at head     | New node.next = old head                   |
| Insert at end      | Reach last node, make last.next = new node |
| Insert at position | Walk to (pos−1), update pointers           |
| Delete head        | head = head->next                          |
| Delete tail        | Reach second last and set next = NULL      |
| Delete by value    | Find value, relink around it               |
| Length             | Count nodes until NULL                     |

### 6. Time Complexity Summary

| Operation                  | Time Complexity                       |
| -------------------------- | ------------------------------------- |
| Access element             | O(n)                                  |
| Search                     | O(n)                                  |
| Insert at head             | O(1)                                  |
| Insert at end              | O(n) (unless tail pointer maintained) |
| Delete head                | O(1)                                  |
| Delete tail / delete value | O(n)                                  |
| Space per node             | Data + pointer (8 or 12 bytes approx) |

### 7. Linked List vs Array (Expanded)

| Feature            | Array                    | Linked List                    |
| ------------------ | ------------------------ | ------------------------------ |
| Memory layout      | Continuous               | Scattered (dynamic allocation) |
| Resize             | Difficult                | Easy, just add nodes           |
| Cache friendliness | High (contiguous memory) | Lower                          |
| Insertion at start | O(n) shift required      | O(1)                           |
| Random access      | O(1) direct index        | O(n) traversal                 |

### 8. When NOT to use Linked List

Avoid Linked List if:

* You need fast random index access
* Memory is extremely limited (extra pointer cost)
* You need heavy cache locality (arrays faster for large computing tasks)

### 9. Real-Life Applications

Where Linked Lists are used in real systems:

| Use Case               | How it uses Linked List        |
| ---------------------- | ------------------------------ |
| Web Browser History    | Back/Forward navigation        |
| Music/Video Playlist   | Next/previous track            |
| Undo operations        | Stored as linked operations    |
| Memory allocation (OS) | Free block management          |
| Hashing (Chaining)     | Each bucket uses a linked list |
