## LINKED LIST (SINGLY / 1D LINKED LIST)

## 1. What is a Linked List?

A Linked List is a **linear data structure** where elements are stored in separate memory blocks called **nodes**, and each node stores:

1. Data (value)
2. Address of the next node (pointer)

Representation:

```
[ Data | Next ] -> [ Data | Next ] -> [ Data | Next ] -> NULL
```

### Why not just use Arrays?

Arrays have limitations:

| Feature       | Array                            | Linked List                     |
| ------------- | -------------------------------- | ------------------------------- |
| Size          | Fixed                            | Dynamic                         |
| Memory        | Contiguous blocks needed         | Scattered nodes allowed         |
| Insert/Delete | Costly because shifting required | Efficient, only pointer updates |
| Access        | Fast O(1) by index               | Slow O(n), must traverse        |

Real example:
Car parking data size changes daily. Array needs fixed capacity. Linked List grows/shrinks dynamically.

---

## 2. Node Structure (C++)

We need a structure/class because every node stores **two fields**.

```cpp
// File: linkedlist_intro.cpp
#include <bits/stdc++.h>
using namespace std;

class Node {
public:
    int data;     // value stored
    Node* next;   // pointer to next node

    // Constructor 1: data + next pointer
    Node(int data1, Node* next1) {
        data = data1;
        next = next1;
    }

    // Constructor 2: only data, next = NULL
    Node(int data1) {
        data = data1;
        next = nullptr;
    }
};

int main() {
    vector<int> arr = {2, 5, 8, 7};

    Node* y = new Node(arr[0]); // creating first node dynamically

    cout << y << "\n";       // prints memory address of the node
    cout << y->data << "\n"; // prints value stored in node

    return 0;
}
```

### Output (example):

```
0x61fef0
2
```

---

## 3. Understanding Node vs Node*

| Term    | Meaning                                  |
| ------- | ---------------------------------------- |
| `Node`  | An object containing data + next pointer |
| `Node*` | A pointer storing address of a Node      |

Example:

```cpp
Node a(10);   // Node object
Node* p = &a; // pointer storing address of node a
```

---

## 4. Understanding Pointers (Why needed?)

A pointer allows storing **address** of another variable in memory.

Because Linked List nodes are scattered in memory, we connect them using pointers.

```
Node A data=10 next → Node B data=20 next → Node C data=30 next → NULL
```

---

## 5. Memory Usage

In each node, we store:

1. int data → 4 Bytes
2. pointer next → depends on system

| System | Pointer size | Node Total Size |
| ------ | ------------ | --------------- |
| 32-bit | 4 Bytes      | 8 Bytes         |
| 64-bit | 8 Bytes      | 12 Bytes        |

So Linked List uses **extra memory overhead**.

---

## 6. Types of Linked Lists

| Type                 | Description               |
| -------------------- | ------------------------- |
| Singly Linked List   | Points only to next node  |
| Doubly Linked List   | Points to next + previous |
| Circular Linked List | Last node points to head  |

We are learning **Singly Linked List**.

---

## 7. Basic Operations (Singly LL)

We will implement:

| Operation              | Complexity |
| ---------------------- | ---------- |
| Traversal              | O(n)       |
| Insert at Beginning    | O(1)       |
| Insert at End          | O(n)       |
| Insert at Position     | O(n)       |
| Delete Node (by value) | O(n)       |
| Search                 | O(n)       |

---

## 8. Create Linked List & Traverse

```cpp
// File: create_and_traverse.cpp
#include <bits/stdc++.h>
using namespace std;

class Node {
public:
    int data;
    Node* next;
    Node(int data1) {
        data = data1;
        next = nullptr;
    }
};

void printList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << "\n";
}

int main() {
    // Manually linking nodes
    Node* n1 = new Node(10);
    Node* n2 = new Node(20);
    Node* n3 = new Node(30);

    n1->next = n2;
    n2->next = n3;
    n3->next = nullptr;

    Node* head = n1;

    printList(head);

    return 0;
}
```

### Output

```
10 20 30
```

---

## 9. Dry Run (Pointer Flow)

```
head → [10 | *] → [20 | *] → [30 | NULL]
```

Traversal:
temp=head → prints 10
temp moves to next → prints 20
temp moves to next → prints 30
temp becomes NULL → stop

---

## 10. Insert at Beginning

```cpp
Node* insertAtBegin(Node* head, int value) {
    Node* newNode = new Node(value);
    newNode->next = head;
    return newNode;
}
```

---

## 11. Insert at End

```cpp
Node* insertAtEnd(Node* head, int value) {
    Node* newNode = new Node(value);

    if (head == nullptr) return newNode;

    Node* temp = head;
    while (temp->next != nullptr) {
        temp = temp->next;
    }
    temp->next = newNode;
    return head;
}
```

---

## 12. Delete (Node by Value)

```cpp
Node* deleteValue(Node* head, int value) {
    if (!head) return head;

    if (head->data == value) {
        Node* temp = head;
        head = head->next;
        delete temp;
        return head;
    }

    Node* curr = head;
    while (curr->next && curr->next->data != value)
        curr = curr->next;

    if (curr->next) {
        Node* temp = curr->next;
        curr->next = curr->next->next;
        delete temp;
    }
    return head;
}
```

---

## 13. Applications of Linked List

Used in:

1. Web Browser Forward/Back Navigation
2. Music Playlist
3. Undo/Redo in editors
4. Dynamic Memory Allocation
5. Implementing Stacks, Queues, Hash Chaining

---

## 14. Key Interview Questions

1. Reverse a Linked List (Iterative + Recursive)
2. Find middle of Linked List (slow/fast pointer)
3. Detect cycle (Floyd’s Cycle Detection)
4. Remove cycle in Linked List
5. Merge two sorted linked lists
6. Add 2 numbers stored in LL
7. Check if LL is palindrome
8. Delete Nth node from end (two pointer)
9. Intersection of two linked lists
10. Sort linked list (Merge Sort)

---

## 15. Summary Table

| Feature        | Linked List               |
| -------------- | ------------------------- |
| Memory         | Non-contiguous            |
| Access         | O(n)                      |
| Insert/Delete  | O(1) at head, O(n) at end |
| Extra space    | Pointer overhead          |
| Implementation | Uses pointers             |

---