# Insert at the Head of a Linked List


### 1. Problem Statement

Given the head of a singly linked list and an integer `val`, insert a new node containing `val` **before the current head** and return the new head.

### Example

Linked List (before):

```
2 -> 3
```

Insert value: `1`

Linked List (after):

```
1 -> 2 -> 3
```

### 2. Why do we need this operation?

In Linked Lists, inserting at the beginning is an extremely common operation such as:

* Implementing Stacks (push = insert at head)
* Adding recent history (browser, media player)
* Efficient insertion (no shifting like arrays)

Insertion at head is **O(1)** whereas in arrays inserting at the start is **O(n)** due to shifting.

### 3. Concept / How it works

We perform three steps:

| Step | Description                         |
| ---- | ----------------------------------- |
| 1    | Create a new node with given value  |
| 2    | Point newNode->next to current head |
| 3    | Return newNode as new head          |

Linked structure before:

```
head → [2 | *] → [3 | NULL]
```

After insert value=1:

```
head → [1 | *] → [2 | *] → [3 | NULL]
```

### 4. Algorithm

1. Create a new node with data = val.
2. Set newNode->next = head.
3. Return newNode as the updated head.

### 5. Dry Run

Initial:

```
head = 2 -> 3
Insert value = 1
```

Step-by-step:

```
newNode = [1 | *]
newNode->next = head (node with value 2)
head becomes newNode
```

Final:

```
1 -> 2 -> 3
```

### 6. C++ Implementation (with clean comments)

```cpp
#include <bits/stdc++.h>
using namespace std;

// Node represents a single element of the linked list
class Node {
public:
    int data;      // value stored in the node
    Node* next;    // pointer to next node

    // Constructor with data + next pointer
    Node(int data1, Node* next1) {
        data = data1;
        next = next1;
    }

    // Constructor with only data
    Node(int data1) {
        data = data1;
        next = nullptr;
    }
};

// Class containing linked list operations
class Solution {
public:
    // Insert new node before head and return new head
    Node* insertAtHead(Node* head, int newData) {
        // Create new node pointing to current head
        Node* newNode = new Node(newData, head);
        return newNode; // newNode becomes new head
    }

    // Utility function to print linked list
    void printList(Node* head) {
        Node* temp = head;
        while (temp != nullptr) {
            cout << temp->data << " ";
            temp = temp->next;
        }
        cout << endl;
    }
};

int main() {
    Solution sol;

    // Creating example list: 2 -> 3
    Node* head = new Node(2);
    head->next = new Node(3);

    cout << "Original List: ";
    sol.printList(head);

    // Insert 1 at head
    head = sol.insertAtHead(head, 1);

    cout << "After Insertion at Head: ";
    sol.printList(head);

    return 0;
}
```

### Output:

```
Original List: 2 3
After Insertion at Head: 1 2 3
```

### 7. Complexity Analysis

| Operation | Complexity                               |
| --------- | ---------------------------------------- |
| Time      | O(1)                                     |
| Space     | O(1) extra space (only one node created) |

### 8. Common Mistakes in Interviews

| Mistake                       | Explanation                                     |
| ----------------------------- | ----------------------------------------------- |
| Forgetting to return new head | If you don’t return new head, insertion is lost |
| Not handling empty list       | If head == NULL, new node becomes head          |
| Using arrays mindset          | No shifting needed, only pointer change         |

### 9. Interview Follow-Up Questions

Be prepared to answer these next:

1. Insert at end of linked list
2. Insert at a specific position K
3. Delete node by value
4. Delete head node
5. Reverse a linked list (very important)
6. Find middle node (slow-fast pointer)
7. Detect cycle in linked list
