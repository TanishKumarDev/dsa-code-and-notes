
# Delete Last Node of a Singly Linked List


### 1. Problem Statement

Given the head of a singly linked list, delete its **last node (tail)** and return the updated list.

### 2. Why this is needed?

Deleting the last node is common in:

* Removing last visited browser pages
* Removing last song in a playlist
* Stack/Undo-like functionalities when implemented using linked lists

### 3. Key Insight (How it works?)

To delete the last node, we need to reach the **second last node** because we must change:

Before:

```
A → B → C → NULL   (Delete C)
```

After:

```
A → B → NULL
```

Then we delete memory for C.

### 4. Edge Cases

| Case             | Meaning                                   |
| ---------------- | ----------------------------------------- |
| Empty List       | Nothing to delete, return NULL            |
| Single Node List | Delete that node and return NULL          |
| Normal List      | Traverse to second last node, delete last |

### 5. Algorithm

1. If head is NULL → return NULL
2. If head->next is NULL (only 1 node) → delete head, return NULL
3. Traverse list until `curr->next->next == NULL` (second last node)
4. Delete `curr->next` (tail)
5. Set `curr->next = NULL`
6. Return head

### 6. Dry Run

Input Linked List:

```
1 → 2 → 3 → NULL
```

Traversal:

```
curr = 1 (curr->next->next != NULL, continue)
curr = 2 (curr->next->next == NULL, stop here)
```

Delete:

* delete node 3
* curr->next = NULL

Final List:

```
1 → 2 → NULL
```

### 7. Fully Commented C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

// Node structure for singly linked list
struct Node {
    int data;
    Node* next;

    // constructor initializes node with value and next = NULL
    Node(int val) {
        data = val;
        next = NULL;
    }
};

class Solution {
public:
    // Function to delete the tail (last node) of linked list
    Node* deleteTail(Node* head) {

        // Case 1: Empty list
        if (head == NULL) return NULL;

        // Case 2: Only one node in list
        if (head->next == NULL) {
            delete head;     // free memory
            return NULL;     // returning empty list
        }

        // Case 3: General case: Traverse to second last node
        Node* curr = head;
        while (curr->next->next != NULL) {
            curr = curr->next;   // move forward
        }

        // curr now points to second last node
        delete curr->next;       // delete last node
        curr->next = NULL;       // mark new tail

        return head;             // return updated list
    }
};

// Utility function to print linked list
void printList(Node* head) {
    Node* temp = head;
    while (temp) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

// Driver code
int main() {
    // Creating linked list: 1 -> 2 -> 3
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);

    Solution obj;

    cout << "Original List: ";
    printList(head);

    // Perform delete tail
    head = obj.deleteTail(head);

    cout << "After Deleting Tail: ";
    printList(head);

    return 0;
}
```

### 8. Output

```
Original List: 1 2 3
After Deleting Tail: 1 2
```

### 9. Time & Space Complexity

| Operation   | Complexity |
| ----------- | ---------- |
| Traversal   | O(n)       |
| Delete Tail | O(n)       |
| Space Used  | O(1)       |

### 10. Git Commit Message

```
feat: added deleteTail operation for singly linked list

- Handles empty list and single-node list cases
- Traverses to second last node to remove tail safely
- Includes dry run explanation and utility print function
```

### 11. Follow-up Interview Questions

Next suggested problems after this one:

1. Delete head of Linked List
2. Delete node by value
3. Delete node at position k
4. Reverse Linked List
5. Find middle node (slow-fast pointers)
6. Detect and remove cycle

---


Reply with:

1. Delete Head Node
2. Delete Node by Value
3. Delete Node at Position K
4. Reverse Linked List (Iterative + Recursion)
5. Middle / Cycle Detection (Fast-Slow Pointer)
6. Insert at Tail
7. Insert at Kth Position