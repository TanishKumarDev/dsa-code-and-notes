
# Find the Length of a Linked List

### 1. Problem Statement

Given the head of a linked list, count and return the number of nodes present in that linked list.

### 2. Why this is needed?

Counting nodes is useful in many linked list operations, such as:

* Finding the middle node
* Validating K-th insertion/deletion
* Length comparison in intersection problems

### 3. Approach / How to solve?

Traverse the linked list from head to NULL and keep a counter.

Visualization:

```
head → [10] → [20] → [30] → NULL
Count nodes = 3
```

### 4. Algorithm

| Step | Description                               |
| ---- | ----------------------------------------- |
| 1    | Initialize counter = 0                    |
| 2    | Use a temp pointer starting from head     |
| 3    | While temp is not NULL: increment counter |
| 4    | Move temp to next node                    |
| 5    | After loop ends, return counter           |

### 5. Dry Run Example

Input Linked List:

```
10 → 20 → 30 → NULL
```

Traversal Trace:

| temp points to | count |
| -------------- | ----- |
| 10             | 1     |
| 20             | 2     |
| 30             | 3     |
| NULL (stop)    | 3     |

Final Length = 3

### 6. Fully Commented C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

// Node class represents a single node in the linked list
class Node {
public:
    int data;     // value of the node
    Node* next;   // pointer to next node

    // Constructor initializes data and sets next = NULL
    Node(int data1) {
        data = data1;
        next = nullptr;
    }
};

// Class containing operations related to linked list
class Solution {
public:

    // Function to find the length of the linked list
    int lengthOfLinkedList(Node* head) {
        int count = 0;          // counter to count nodes
        Node* temp = head;      // start traversal from the head

        // Traverse entire list until temp becomes NULL
        while (temp != nullptr) {
            count++;            // count current node
            temp = temp->next;  // move to next node
        }

        return count;           // return total number of nodes
    }
};

int main() {
    // Create sample linked list: 10 -> 20 -> 30
    Node* head = new Node(10);
    head->next = new Node(20);
    head->next->next = new Node(30);

    Solution obj;

    // Calculate and print length
    cout << "Length of Linked List: "
         << obj.lengthOfLinkedList(head) << endl;

    return 0;
}
```

### 7. Output

```
Length of Linked List: 3
```

### 8. Time & Space Complexity

| Operation | Complexity                        |
| --------- | --------------------------------- |
| Time      | O(N) (Traverse all nodes)         |
| Space     | O(1) (Only a counter and pointer) |

### 9. Git Commit Message

```
feat: added lengthOfLinkedList function for singly linked list

- Iterative traversal counts nodes until NULL
- Handles empty list case returning length 0
- Includes dry run example and full code comments
```

### 10. Follow-up Interview Questions

After understanding length, interviewers often ask:

| Question                              | Why?                                      |
| ------------------------------------- | ----------------------------------------- |
| Find middle of Linked List            | Uses length or two-pointer technique      |
| Check if Linked List is palindrome    | Often requires length knowledge           |
| Delete Kth node                       | Valid only if length >= K                 |
| Rotate Linked List                    | Length helps compute new head efficiently |
| Find intersection of two linked lists | Compares lengths                          |